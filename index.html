<!DOCTYPE html><html lang="en"><head>   <meta charset="UTF-8">   <meta name="viewport" content="width=device-width, initial-scale=1.0">   <title>Sansoku - Fast & Strong AI Edition</title>   <script src="https://cdn-tailwindcss.vercel.app/"></script>   <style>       @import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;800&display=swap');       body {           font-family: 'M PLUS Rounded 1c', sans-serif;           -webkit-tap-highlight-color: transparent;       }       .cell {           width: 55px; height: 55px; display: flex; justify-content: center; align-items: center;           font-size: 1.5rem; font-weight: 800; border: 2px solid #ccc; cursor: pointer; transition: all 0.2s ease;       }       @media (max-width: 640px) {           .cell { width: 48px; height: 48px; font-size: 1.1rem; }       }       .player1 { background-color: #e0f2fe; border-color: #38bdf8; }       .player2 { background-color: #fee2e2; border-color: #f87171; }       .initial { background-color: #f3f4f6; border-color: #9ca3af; }       .calculable:hover { background-color: #d1fae5; }       .modal {           display: none; position: fixed; z-index: 10; left: 0; top: 0;           width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5);           justify-content: center; align-items: center;       }       .modal-content {           background-color: #fefefe; margin: auto; padding: 20px; border: 1px solid #888;           width: 90%; max-width: 500px; border-radius: 10px; text-align: center;       }       .active-turn {           transform: scale(1.05); box-shadow: 0 4px 15px -2px rgba(0,0,0,0.2);           border-bottom: 4px solid; transition: all 0.3s ease;       }       .player1-active { border-color: #38bdf8; }       .player2-active { border-color: #f87171; }       .game-container { display: none; }   </style></head><body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">   <div id="mode-selection" class="w-full max-w-lg mx-auto bg-white rounded-xl shadow-lg p-8 text-center">       <h1 class="text-4xl font-extrabold text-gray-800 mb-6">Sansoku</h1>       <p class="text-gray-600 mb-8">Select a game mode</p>       <div class="space-y-4">           <button id="pvp-button" class="w-full bg-sky-500 hover:bg-sky-600 text-white font-bold py-4 px-6 rounded-lg text-xl transition-transform transform hover:scale-105">               Player vs Player           </button>           <button id="pva-button" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-4 px-6 rounded-lg text-xl transition-transform transform hover:scale-105">               Player vs Strong AI           </button>       </div>   </div>   <div id="game-container" class="game-container w-full max-w-lg mx-auto bg-white rounded-xl shadow-lg p-6">       <h1 class="text-4xl font-extrabold text-center text-gray-800 mb-4">Sansoku</h1>              <div class="flex justify-around my-4 text-center">           <div id="player1-info" class="p-3 rounded-lg w-32 transition-all">               <p class="font-bold text-sky-500">Player 1</p>               <p id="score1" class="text-3xl font-bold">0</p>           </div>           <div id="player2-info" class="p-3 rounded-lg w-32 transition-all">               <p id="player2-label" class="font-bold text-red-500">Player 2</p>               <p id="score2" class="text-3xl font-bold">0</p>               <p id="ai-status" class="text-sm text-red-500 h-5"></p>           </div>       </div>       <div id="board" class="grid grid-cols-6 gap-1 mx-auto w-max mb-4"></div>       <button id="back-to-menu" class="w-full mt-2 bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg">Back to Menu</button>   </div>      <!-- Modals -->   <div id="operation-modal" class="modal"><div class="modal-content"><div id="operation-choices" class="space-y-4 max-h-60 overflow-y-auto"></div><button id="cancel-op" class="mt-6 bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg">Cancel</button></div></div>   <div id="result-modal" class="modal"><div class="modal-content"><h2 id="result-title" class="text-2xl font-bold mb-4"></h2><p id="result-message" class="mb-6"></p><button id="restart-button" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg mr-2">Restart</button><button id="menu-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg">Menu</button></div></div>      <script>       const modeSelection=document.getElementById("mode-selection"),gameContainer=document.getElementById("game-container"),boardElement=document.getElementById("board"),score1Element=document.getElementById("score1"),score2Element=document.getElementById("score2"),player1Info=document.getElementById("player1-info"),player2Info=document.getElementById("player2-info"),player2Label=document.getElementById("player2-label"),aiStatus=document.getElementById("ai-status"),operationModal=document.getElementById("operation-modal"),resultModal=document.getElementById("result-modal");       const BOARD_SIZE=6;       let board=[],currentPlayer=1,gameState="PLAYING",scores={1:0,2:0},selectedTargetIndex=null,turnCount=0,movePatterns=[],highlightedSources=[],gameMode="pvp";       let aiWorker;       const workerCode = `           let movePatternsCache = null;           function generateMovePatterns(size) {               if (movePatternsCache) return movePatternsCache;               const patterns = [];               for (let r = 0; r < size; r++) for (let c = 0; c < size - 2; c++) { const base = r * size + c; patterns.push([base + 2, base + 1, base]); patterns.push([base, base + 1, base + 2]); }               for (let r = 0; r < size - 2; r++) for (let c = 0; c < size; c++) { const base = r * size + c; patterns.push([base + 2 * size, base + size, base]); patterns.push([base, base + size, base + 2 * size]); }               for (let r = 0; r < size - 2; r++) for (let c = 0; c < size - 2; c++) { const base = r * size + c; patterns.push([base + 2 * size + 2, base + size + 1, base]); patterns.push([base, base + size + 1, base + 2 * size + 2]); }               for (let r = 2; r < size; r++) for (let c = 0; c < size - 2; c++) { const base = r * size + c; patterns.push([base - 2 * size + 2, base - size + 1, base]); patterns.push([base, base - size + 1, base - 2 * size + 2]); }               movePatternsCache = patterns;               return patterns;           }           function findPossibleMoves(board, movePatterns) {               const moves = new Set();               movePatterns.forEach(pattern => {                   const [target, src1, src2] = pattern;                   if (board[target].value === null && board[src1].value !== null && board[src2].value !== null) {                       moves.add(target);                   }               });               return Array.from(moves);           }           function getOperationSourcesForMove(board, target, movePatterns) {               const sources = [];               movePatterns.forEach(pattern => {                   const [t, src1, src2] = pattern;                   if (t === target && board[src1].value !== null && board[src2].value !== null) {                       const exists = sources.some(s => (s.sourceIndices.includes(src1) && s.sourceIndices.includes(src2)));                       if (!exists) {                           sources.push({ num1: board[src1].value, num2: board[src2].value, sourceIndices: [src1, src2] });                       }                   }               });               return sources;           }           function minimax(simBoard, simScores, depth, alpha, beta, isMaximizing, turnCount, movePatterns) {               if (depth === 0 || turnCount >= 36) {                   return simScores[2] - simScores[1];               }               const possibleTargets = findPossibleMoves(simBoard, movePatterns);               if (possibleTargets.length === 0) {                   return simScores[2] - simScores[1];               }                              let moves = [];               for (const target of possibleTargets) {                   const sources = getOperationSourcesForMove(simBoard, target, movePatterns);                   for (const source of sources) {                       const d1 = source.num1 % 10;                       const d2 = source.num2 % 10;                       moves.push({ target, value: d1 + d2 });                       moves.push({ target, value: Math.abs(d1 - d2) });                       moves.push({ target, value: d1 * d2 });                   }               }               if (isMaximizing) {                   moves.sort((a, b) => b.value - a.value);                   let maxEval = -Infinity;                   for (const move of moves) {                       const newBoard = simBoard.map(c => ({...c}));                       const newScores = {...simScores};                       newBoard[move.target] = { value: move.value, player: 2 };                       newScores[2] += move.value;                       const evaluation = minimax(newBoard, newScores, depth - 1, alpha, beta, false, turnCount + 1, movePatterns);                       maxEval = Math.max(maxEval, evaluation);                       alpha = Math.max(alpha, evaluation);                       if (beta <= alpha) break;                   }                   return maxEval;               } else {                   moves.sort((a, b) => a.value - b.value);                   let minEval = Infinity;                   for (const move of moves) {                       const newBoard = simBoard.map(c => ({...c}));                       const newScores = {...simScores};                       newBoard[move.target] = { value: move.value, player: 1 };                       newScores[1] += move.value;                       const evaluation = minimax(newBoard, newScores, depth - 1, alpha, beta, true, turnCount + 1, movePatterns);                       minEval = Math.min(minEval, evaluation);                       beta = Math.min(beta, evaluation);                       if (beta <= alpha) break;                   }                   return minEval;               }           }                      self.onmessage = (e) => {               const { board, scores, turnCount } = e.data;               const movePatterns = generateMovePatterns(6);               const possibleTargets = findPossibleMoves(board, movePatterns);               if (possibleTargets.length === 0) {                   self.postMessage(null);                   return;               };               const searchDepth = turnCount < 22 ? 2 : 3;               let bestMove = null;               let bestValue = -Infinity;               for (const target of possibleTargets) {                   const sources = getOperationSourcesForMove(board, target, movePatterns);                   for (const source of sources) {                       const d1 = source.num1 % 10;                       const d2 = source.num2 % 10;                       const operations = [d1 + d2, Math.abs(d1 - d2), d1 * d2];                       for (const value of operations) {                           const newBoard = board.map(c => ({...c}));                           const newScores = {...scores};                           newBoard[target] = { value: value, player: 2 };                           newScores[2] += value;                           const moveValue = minimax(newBoard, newScores, searchDepth - 1, -Infinity, Infinity, false, turnCount + 1, movePatterns);                           if (moveValue > bestValue) {                               bestValue = moveValue;                               bestMove = { target, value };                           }                       }                   }               }               self.postMessage(bestMove);           };       `;              function setupWorker() {           try {               const blob = new Blob([workerCode], { type: 'application/javascript' });               const workerUrl = URL.createObjectURL(blob);               aiWorker = new Worker(workerUrl);               aiWorker.onmessage = (e) => {                   const bestMove = e.data;                   if (bestMove) {                       placeNumber(bestMove.target, bestMove.value, 2);                   } else {                       // No move found, switch turn back or end game                       switchTurn();                   }                   boardElement.style.pointerEvents = 'auto';                   aiStatus.textContent = '';               };                aiWorker.onerror = (e) => {                   console.error('Worker error:', e);                   aiStatus.textContent = 'AI Error';                   boardElement.style.pointerEvents = 'auto';               };           } catch (error) {               console.error("Failed to create AI worker:", error);               alert("Could not initialize the AI. Please try refreshing the page.");           }       }       function generateMovePatterns(e){const t=[];for(let s=0;s<e;s++)for(let o=0;o<e-2;o++){const n=s*e+o;t.push([n+2,n+1,n]),t.push([n,n+1,n+2])}for(let s=0;s<e-2;s++)for(let o=0;o<e;o++){const n=s*e+o;t.push([n+2*e,n+e,n]),t.push([n,n+e,n+2*e])}for(let s=0;s<e-2;s++)for(let o=0;o<e-2;o++){const n=s*e+o;t.push([n+2*e+2,n+e+1,n]),t.push([n,n+e+1,n+2*e+2])}for(let s=2;s<e;s++)for(let o=0;o<e-2;o++){const n=s*e+o;t.push([n-2*e+2,n-e+1,n]),t.push([n,n-e+1,n-2*e+2])}return t}       function startGame(e){gameMode=e,modeSelection.style.display="none",gameContainer.style.display="block",player2Label.textContent="pva"===gameMode?"Strong AI":"Player 2",initGame()}       function initGame(){board=Array(36).fill(null).map(()=>({value:null,player:null})),scores={1:16,2:0},currentPlayer=1,gameState="PLAYING",movePatterns=generateMovePatterns(6);const e=(BOARD_SIZE/2-1)*BOARD_SIZE+BOARD_SIZE/2-1,t={[e]:1,[e+1]:2,[e+BOARD_SIZE]:2,[e+BOARD_SIZE+1]:1};Object.entries(t).forEach(([e,t])=>{board[e]={value:t,player:0}}),turnCount=4;if(gameMode === 'pva' && !aiWorker) setupWorker(); render(),updateActivePlayerUI()}       function switchTurn(){currentPlayer=1===currentPlayer?2:1,updateActivePlayerUI(),"pva"===gameMode&&2===currentPlayer&&"PLAYING"===gameState&&makeAIMove()}       function placeNumber(e,t,s){board[e]={value:t,player:s},scores[s]+=t,turnCount++,36===turnCount?(gameState="GAME_OVER",render(),showResult()):(switchTurn(),render())}       function findPossibleMoves(e){const t=new Set;return"PLAYING"!==gameState?[]:(movePatterns.forEach(s=>{const[o,n,a]=s;null===e[o].value&&null!==e[n].value&&null!==e[a].value&&t.add(o)}),Array.from(t))}       function getOperationSourcesForMove(e,t){const s=[];return movePatterns.forEach(o=>{const[n,a,r]=o;if(n===t&&null!==e[a].value&&null!==e[r].value){const t=s.some(e=>e.sourceIndices.includes(a)&&e.sourceIndices.includes(r));t||s.push({num1:e[a].value,num2:e[r].value,sourceIndices:[a,r]})}}),s}       function makeAIMove(){boardElement.style.pointerEvents="none",aiStatus.textContent="Thinking...",aiWorker.postMessage({board:board,scores:scores,turnCount:turnCount})}       function updateActivePlayerUI(){"PLAYING"===gameState?(player1Info.classList.toggle("active-turn",1===currentPlayer),player1Info.classList.toggle("player1-active",1===currentPlayer),player2Info.classList.toggle("active-turn",2===currentPlayer),player2Info.classList.toggle("player2-active",2===currentPlayer)):(player1Info.classList.remove("active-turn","player1-active"),player2Info.classList.remove("active-turn","player2-active"))}       function showResult(){const e=document.getElementById("result-title"),t=document.getElementById("result-message");scores[1]>scores[2]?e.textContent="Player 1 Wins!":scores[2]>scores[1]?e.textContent=("pva"===gameMode?"Strong AI":"Player 2")+" Wins!":e.textContent="Draw!",t.innerHTML=`Player 1: ${scores[1]}<br>${"pva"===gameMode?"Strong AI":"Player 2"}: ${scores[2]}`,resultModal.style.display="flex"}       function render(){boardElement.innerHTML="";const e=findPossibleMoves(board);board.forEach((t,s)=>{const o=document.createElement("div");o.classList.add("cell","rounded-md"),o.dataset.index=s,o.addEventListener("click",()=>onCellClick(s)),highlightedSources.includes(s)&&(o.style.boxShadow="0 0 10px 3px #facc15"),null!==t.value?(o.textContent=t.value,0===t.player?o.classList.add("initial","font-bold"):o.classList.add(1===t.player?"player1":"player2","font-bold")):"PLAYING"===gameState&&e.includes(s)?o.classList.add("calculable"):o.style.cursor="not-allowed",boardElement.appendChild(o)}),score1Element.textContent=scores[1],score2Element.textContent=scores[2],updateActivePlayerUI()}       function onCellClick(e){if(("pva"===gameMode&&2===currentPlayer||null!==board[e].value||"PLAYING"!==gameState))return;const t=getOperationSourcesForMove(board,e);if(0===t.length)return;selectedTargetIndex=e;const s=document.getElementById("operation-choices");s.innerHTML="",t.forEach(t=>{const{num1:e,num2:o,sourceIndices:n}=t,a=e%10,r=o%10,l=document.createElement("div");l.className="p-3 border rounded-lg bg-gray-50 flex justify-center items-center gap-4";const c=document.createElement("div");c.textContent=e,c.className="w-12 h-12 flex items-center justify-center font-bold text-lg rounded-md "+(1===board[n[0]].player?"player1":2===board[n[0]].player?"player2":"initial");const i=document.createElement("div");i.textContent=o,i.className="w-12 h-12 flex items-center justify-center font-bold text-lg rounded-md "+(1===board[n[1]].player?"player1":2===board[n[1]].player?"player2":"initial");const u=document.createElement("div");u.className="flex flex-wrap justify-center gap-2";[{name:"+",value:a+r},{name:"-",value:Math.abs(a-r)},{name:"×",value:a*r}].forEach(e=>{const t=document.createElement("button");t.textContent=e.name,t.className="bg-green-500 hover:bg-green-600 text-white font-bold py-2 w-12 rounded-lg text-xl",t.onclick=()=>{highlightedSources=[],placeNumber(selectedTargetIndex,e.value,currentPlayer),operationModal.style.display="none"},u.appendChild(t)}),l.appendChild(c),l.appendChild(i),l.appendChild(u),l.onmouseover=()=>{highlightedSources=n,render()},l.onmouseout=()=>{highlightedSources=[],render()},s.appendChild(l)}),operationModal.style.display="flex"}       document.getElementById("pvp-button").addEventListener("click",()=>startGame("pvp"));       document.getElementById("pva-button").addEventListener("click",()=>startGame("pva"));       document.getElementById("back-to-menu").addEventListener("click",()=>{gameContainer.style.display="none",modeSelection.style.display="block"});       document.getElementById("cancel-op").addEventListener("click",()=>{highlightedSources=[],render(),operationModal.style.display="none"});       document.getElementById("restart-button").addEventListener("click",()=>{resultModal.style.display="none",initGame()});       document.getElementById("menu-button").addEventListener("click",()=>{resultModal.style.display="none",gameContainer.style.display="none",modeSelection.style.display="block"});   </script></body></html>